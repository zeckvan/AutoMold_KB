# 📑 AutoMold_Thread2 自動排模排產邏輯二（細部規則）

## 1. 資料來源與篩選條件
- **來源表**：`AutoMold_ArticleMold`  
- **篩選條件**：  
  - `SumBodySizeNeed > 0` （型體 Size 欠數大於 0）  
  - `建議上模塊數 − 實際排班上模數 > 0`  
- **排序**：依 `SortMold` 由小到大  

---

## 2. 無資料情境
- 若無符合條件的 `AutoMold_ArticleMold`：  
  1. 檢查 `AutoMold_ProductionScheduleDay`（生產排班日資訊）是否仍有未處理資料。  
  2. 若 **有** → 讀取下一筆 `AutoMold_ProductionScheduleDay` → 重新進入 **排模排產五項邏輯**。  
  3. 若 **沒有** → 結束整體排模排產邏輯。  

---

## 3. 有資料情境（逐筆處理）

### 3.1 找尋【前班機台孔位資訊】
- **來源表**：`AutoMold_Produce`  
- **連結條件**：  
  - `AutoMold_ArticleMold.MoldNo = AutoMold_Produce.MoldNo`  
  - `AutoMold_ArticleMold.ZZPARTNO = AutoMold_Produce.ZZPARTNO`  
  - `AutoMold_ArticleMold.ProductSize ≈ AutoMold_Produce.ProductSize`（取最接近值）  
- **排序**：依 `ResourceId`（機台孔位代碼）由小到大  
- **處理限制**：  
  - 已處理筆數 ≤ `AutoMold_ArticleMold.建議上模塊數`  

---

### 3.2 檢查【共模情境】
- **來源表**：`AutoMold_Temp`, `BMolds`  
- **條件**：  
  - `AutoMold_ArticleMold.MoldNo = BMolds.MoldNo`  
  - `AutoMold_ArticleMold.ProductSize = BMolds.ProductSize`
  - `AutoMold_ArticleMold.ZZGENDER = BMolds.ZZGENDER`
  - `AutoMold_ArticleMold.ZZPARTNO = BMolds.COMPONENT`
  - `AutoMold_Temp.ProductId = BMolds.ProductId`
  - `AutoMold_Temp.MoldPcsSeq <> BMolds.MoldPcsSeq`
  - `AutoMold_Temp.ShiftName = AutoMold_ProductionScheduleDay.ShiftName`
  - `AutoMold_Temp.ShiftDate = AutoMold_ProductionScheduleDay.ShiftDate`

- **處理邏輯**：  
  - 若找到 →  
    1.  新增一筆紀錄至 `AutoMold_Temp`

    2.  更新 `AutoMold_ArticleMold`：

        - 欄位： 
            -   `SumBodySizeNeed -= AutoMold_Temp.ShiftWorkQty`
            -   `ActualRequiredUpperMoldQuantity += 1`
        - 條件：
            -   `SortMold = AutoMold_ArticleMold.SortMold`   

    3.  更新 `AutoMold_WorkMold`：

        - 欄位：   
            -   `MoldedQuantity += AutoMold_Temp.ShiftWorkQty`
            -   `UnmoldedQuantity = GAMNG − MoldedQuantity`
        - 條件：
            -   AufnrSeq = 
            ``` sql
            SELECT TOP 1 AutoMold_WorkMold.AufnrSeq
            FROM AutoMold_WorkMold 
            WHERE AufnrSeq IN AutoMold_ArticleMold.SortOrderList 
            AND UnmoldedQuantity > 0 
            ORDER BY AufnrSeq ASC;
            ```  

  - 若 AutoMold_Temp.WorkQty - AutoMold_Temp.ShiftWorkQty > 0 進入 **3.3 機台餘力分派**  

---

### 3.3 機台餘力分派（相同條件工單）

-   **來源表**：`AutoMold_WorkMold`

-   **條件**：

    -   `AufnrSeq ∈ AutoMold_ArticleMold.SortOrderList`
    -   `UnmoldedQuantity > 0`

-   **排序**：依 `AufnrSeq` 由小到大

-   **SQL 參考**：

    ``` sql
    SELECT *
    FROM AutoMold_WorkMold 
    WHERE AufnrSeq IN AutoMold_ArticleMold.SortOrderList 
      AND UnmoldedQuantity > 0 
    ORDER BY AufnrSeq ASC;
    ```

-   **處理邏輯**：

    -   逐筆寫入 `AutoMold_Temp`
    -   更新 `AutoMold_ArticleMold`（同上規則）
    -   更新 `AutoMold_WorkMold`（同上規則）
    -   持續分派直到
        `AutoMold_Temp.WorkQty - AutoMold_Temp.ShiftWorkQty = 0`（戰力耗盡）

---

### 3.4 確認機台未被排模
- **來源表**：`AutoMold_Temp`  
- **條件**：  
  - 相同 `ResourceId、ShiftDate、ShiftName、FacilityId`  

- **處理邏輯**：  
  - 若有紀錄且不是共模 → 換下一筆機台孔位處理  
  - 若沒有紀錄 →  
    - 新增資料至 `AutoMold_Temp`  
    - 更新 `AutoMold_ArticleMold.SumBodySizeNeed` 與 `ActualRequiredUpperMoldQuantity`  
    - 更新 `AutoMold_WorkMold` 已排與未排數  
    - 若仍有戰力 → 重複 **3.3 機台餘力分派**  

---

## 4. 結束條件
-   當 **型體 Size 欠數** 已完全處理，或
    **所有機台無戰力可再分派**，則：
    -   若有下一筆 `AutoMold_ArticleMold` → 返回 **步驟 3**
    -   若無 → 返回 **步驟 2** 判斷是否換下一筆生產排班日
    -   若也無 → **結束整體邏輯**
